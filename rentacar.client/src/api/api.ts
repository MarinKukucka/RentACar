//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.4.0.0 (NJsonSchema v11.3.2.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

export class ApiClientBase {
    // Base URL can be dynamically set or pulled from environment variables
    baseApiUrl: string = import.meta.env.DEV ? import.meta.env.VITE_API_BACKEND_URI : '';

    // You can set your own language preference or any default settings
    protected getLanguage() {
        // Replace with your preferred logic for setting the language
        return 'en-US'; // Default language if none found
    }

    // If you're using a custom token or just want to fetch it from localStorage
    protected getToken() {
        return localStorage.getItem('auth_token'); // Replace with your token's key
    }

    // Transform the options for the API request
    protected async transformOptions(options: RequestInit): Promise<RequestInit> {
        const token = this.getToken();
        
        options.headers = {
            ...options.headers,
            Authorization: token ? `Bearer ${token}` : '', // If token exists, add it
            'Accept-Language': this.getLanguage(), // Set language header
        };
        options.credentials = 'include'; // If you need to include credentials (cookies)
        
        return options;
    }

    // Transform the API response
    protected async transformResult(
        _url: string,
        response: Response,
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        processor: (response: Response) => any
    ) {
        return processor(response);
    }

    // Get the base URL for the API, with optional override
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    protected getBaseUrl(_defaultUrl?: string, _baseUrl?: string) {
        return this.baseApiUrl;
    }
}

export class AuthClient extends ApiClientBase {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : window as any;
        this.baseUrl = this.getBaseUrl("", baseUrl);
    }

    login(dto: LoginDto): Promise<void> {
        let url_ = this.baseUrl + "/api/Auth/login";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processLogin(_response));
        });
    }

    protected processLogin(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    logout(): Promise<void> {
        let url_ = this.baseUrl + "/api/Auth/logout";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processLogout(_response));
        });
    }

    protected processLogout(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    me(): Promise<UserDto> {
        let url_ = this.baseUrl + "/api/Auth/me";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processMe(_response));
        });
    }

    protected processMe(response: Response): Promise<UserDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            });
        } else if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserDto>(null as any);
    }
}

export class BrandClient extends ApiClientBase {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : window as any;
        this.baseUrl = this.getBaseUrl("", baseUrl);
    }

    getBrandOptions(): Promise<OptionsDto[]> {
        let url_ = this.baseUrl + "/api/Brand/options";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processGetBrandOptions(_response));
        });
    }

    protected processGetBrandOptions(response: Response): Promise<OptionsDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            });
        } else if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(OptionsDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<OptionsDto[]>(null as any);
    }
}

export class ExtraServiceClient extends ApiClientBase {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : window as any;
        this.baseUrl = this.getBaseUrl("", baseUrl);
    }

    getExtraServices(): Promise<ExtraServiceDto[]> {
        let url_ = this.baseUrl + "/api/ExtraService";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processGetExtraServices(_response));
        });
    }

    protected processGetExtraServices(response: Response): Promise<ExtraServiceDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            });
        } else if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ExtraServiceDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ExtraServiceDto[]>(null as any);
    }
}

export class IdentityClient extends ApiClientBase {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : window as any;
        this.baseUrl = this.getBaseUrl("", baseUrl);
    }

    confirmEmail(userId: string | undefined, code: string | undefined, redirectUrl: string | undefined, changedEmail: string | null | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/Identity/confirm-email?";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        if (code === null)
            throw new Error("The parameter 'code' cannot be null.");
        else if (code !== undefined)
            url_ += "code=" + encodeURIComponent("" + code) + "&";
        if (redirectUrl === null)
            throw new Error("The parameter 'redirectUrl' cannot be null.");
        else if (redirectUrl !== undefined)
            url_ += "redirectUrl=" + encodeURIComponent("" + redirectUrl) + "&";
        if (changedEmail !== undefined && changedEmail !== null)
            url_ += "changedEmail=" + encodeURIComponent("" + changedEmail) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processConfirmEmail(_response));
        });
    }

    protected processConfirmEmail(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            });
        } else if (status === 302) {
            return response.text().then((_responseText) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getUserInfo(): Promise<UserInfoResponse> {
        let url_ = this.baseUrl + "/api/Identity/manage/info";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processGetUserInfo(_response));
        });
    }

    protected processGetUserInfo(response: Response): Promise<UserInfoResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            });
        } else if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserInfoResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserInfoResponse>(null as any);
    }

    manageUserInfo(updateUserInfo: UpdateUserInfoRequest): Promise<UserInfoResponse> {
        let url_ = this.baseUrl + "/api/Identity/manage/info";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(updateUserInfo);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processManageUserInfo(_response));
        });
    }

    protected processManageUserInfo(response: Response): Promise<UserInfoResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            });
        } else if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserInfoResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserInfoResponse>(null as any);
    }
}

export class LocationClient extends ApiClientBase {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : window as any;
        this.baseUrl = this.getBaseUrl("", baseUrl);
    }

    getLocationOptions(): Promise<OptionsDto[]> {
        let url_ = this.baseUrl + "/api/Location/options";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processGetLocationOptions(_response));
        });
    }

    protected processGetLocationOptions(response: Response): Promise<OptionsDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            });
        } else if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(OptionsDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<OptionsDto[]>(null as any);
    }

    getLocations(): Promise<LocationDto[]> {
        let url_ = this.baseUrl + "/api/Location";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processGetLocations(_response));
        });
    }

    protected processGetLocations(response: Response): Promise<LocationDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            });
        } else if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(LocationDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<LocationDto[]>(null as any);
    }

    getLocationById(id: number): Promise<LocationDto> {
        let url_ = this.baseUrl + "/api/Location/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processGetLocationById(_response));
        });
    }

    protected processGetLocationById(response: Response): Promise<LocationDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            });
        } else if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LocationDto.fromJS(resultData200);
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<LocationDto>(null as any);
    }
}

export class ModelClient extends ApiClientBase {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : window as any;
        this.baseUrl = this.getBaseUrl("", baseUrl);
    }

    getModelOptionsByBrandId(brandId: number): Promise<OptionsDto[]> {
        let url_ = this.baseUrl + "/api/Model/options/{brandId}";
        if (brandId === undefined || brandId === null)
            throw new Error("The parameter 'brandId' must be defined.");
        url_ = url_.replace("{brandId}", encodeURIComponent("" + brandId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processGetModelOptionsByBrandId(_response));
        });
    }

    protected processGetModelOptionsByBrandId(response: Response): Promise<OptionsDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            });
        } else if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(OptionsDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<OptionsDto[]>(null as any);
    }
}

export class PaymentClient extends ApiClientBase {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : window as any;
        this.baseUrl = this.getBaseUrl("", baseUrl);
    }

    createPaymentIntent(request: PaymentIntentRequest): Promise<PaymentIntentResponse> {
        let url_ = this.baseUrl + "/api/Payment/create-payment-intent";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processCreatePaymentIntent(_response));
        });
    }

    protected processCreatePaymentIntent(response: Response): Promise<PaymentIntentResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            });
        } else if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaymentIntentResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PaymentIntentResponse>(null as any);
    }

    createPayment(command: CreatePaymentCommand): Promise<NewPaymentResponse> {
        let url_ = this.baseUrl + "/api/Payment/create-payment";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processCreatePayment(_response));
        });
    }

    protected processCreatePayment(response: Response): Promise<NewPaymentResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            });
        } else if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = NewPaymentResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<NewPaymentResponse>(null as any);
    }
}

export class PersonClient extends ApiClientBase {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : window as any;
        this.baseUrl = this.getBaseUrl("", baseUrl);
    }

    getPaginatedPeople(paginationFilter_Filter_FirstName: string | null | undefined, paginationFilter_Filter_LastName: string | null | undefined, paginationFilter_Filter_PhoneNumber: string | null | undefined, paginationFilter_CurrentPage: number | undefined, paginationFilter_PageSize: number | undefined, paginationFilter_SortBy: string | undefined, paginationFilter_SortOrder: string | undefined): Promise<PaginationResponseOfPersonDto> {
        let url_ = this.baseUrl + "/api/Person/people?";
        if (paginationFilter_Filter_FirstName !== undefined && paginationFilter_Filter_FirstName !== null)
            url_ += "PaginationFilter.Filter.FirstName=" + encodeURIComponent("" + paginationFilter_Filter_FirstName) + "&";
        if (paginationFilter_Filter_LastName !== undefined && paginationFilter_Filter_LastName !== null)
            url_ += "PaginationFilter.Filter.LastName=" + encodeURIComponent("" + paginationFilter_Filter_LastName) + "&";
        if (paginationFilter_Filter_PhoneNumber !== undefined && paginationFilter_Filter_PhoneNumber !== null)
            url_ += "PaginationFilter.Filter.PhoneNumber=" + encodeURIComponent("" + paginationFilter_Filter_PhoneNumber) + "&";
        if (paginationFilter_CurrentPage === null)
            throw new Error("The parameter 'paginationFilter_CurrentPage' cannot be null.");
        else if (paginationFilter_CurrentPage !== undefined)
            url_ += "PaginationFilter.CurrentPage=" + encodeURIComponent("" + paginationFilter_CurrentPage) + "&";
        if (paginationFilter_PageSize === null)
            throw new Error("The parameter 'paginationFilter_PageSize' cannot be null.");
        else if (paginationFilter_PageSize !== undefined)
            url_ += "PaginationFilter.PageSize=" + encodeURIComponent("" + paginationFilter_PageSize) + "&";
        if (paginationFilter_SortBy === null)
            throw new Error("The parameter 'paginationFilter_SortBy' cannot be null.");
        else if (paginationFilter_SortBy !== undefined)
            url_ += "PaginationFilter.SortBy=" + encodeURIComponent("" + paginationFilter_SortBy) + "&";
        if (paginationFilter_SortOrder === null)
            throw new Error("The parameter 'paginationFilter_SortOrder' cannot be null.");
        else if (paginationFilter_SortOrder !== undefined)
            url_ += "PaginationFilter.SortOrder=" + encodeURIComponent("" + paginationFilter_SortOrder) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processGetPaginatedPeople(_response));
        });
    }

    protected processGetPaginatedPeople(response: Response): Promise<PaginationResponseOfPersonDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            });
        } else if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaginationResponseOfPersonDto.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PaginationResponseOfPersonDto>(null as any);
    }

    createUserAndPerson(command: CreateUserAndPersonCommand): Promise<void> {
        let url_ = this.baseUrl + "/api/Person";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processCreateUserAndPerson(_response));
        });
    }

    protected processCreateUserAndPerson(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            });
        } else if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    disablePerson(id: number): Promise<void> {
        let url_ = this.baseUrl + "/api/Person/deactivate/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "PUT",
            headers: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processDisablePerson(_response));
        });
    }

    protected processDisablePerson(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            });
        } else if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }
}

export class RentalClient extends ApiClientBase {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : window as any;
        this.baseUrl = this.getBaseUrl("", baseUrl);
    }

    createRental(command: CreateRentalCommand): Promise<NoContent> {
        let url_ = this.baseUrl + "/api/Rental";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processCreateRental(_response));
        });
    }

    protected processCreateRental(response: Response): Promise<NoContent> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            });
        } else if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = NoContent.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<NoContent>(null as any);
    }
}

export class ReservationClient extends ApiClientBase {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : window as any;
        this.baseUrl = this.getBaseUrl("", baseUrl);
    }

    getPaginatedReservations(paginationFilter_Filter_Id: number | null | undefined, paginationFilter_Filter_StartDateTime: Date | null | undefined, paginationFilter_Filter_EndDateTime: Date | null | undefined, paginationFilter_Filter_Status: number | null | undefined, paginationFilter_CurrentPage: number | undefined, paginationFilter_PageSize: number | undefined, paginationFilter_SortBy: string | undefined, paginationFilter_SortOrder: string | undefined): Promise<PaginationResponseOfReservationDto> {
        let url_ = this.baseUrl + "/api/Reservation/paginated?";
        if (paginationFilter_Filter_Id !== undefined && paginationFilter_Filter_Id !== null)
            url_ += "PaginationFilter.Filter.Id=" + encodeURIComponent("" + paginationFilter_Filter_Id) + "&";
        if (paginationFilter_Filter_StartDateTime !== undefined && paginationFilter_Filter_StartDateTime !== null)
            url_ += "PaginationFilter.Filter.StartDateTime=" + encodeURIComponent(paginationFilter_Filter_StartDateTime ? "" + paginationFilter_Filter_StartDateTime.toISOString() : "") + "&";
        if (paginationFilter_Filter_EndDateTime !== undefined && paginationFilter_Filter_EndDateTime !== null)
            url_ += "PaginationFilter.Filter.EndDateTime=" + encodeURIComponent(paginationFilter_Filter_EndDateTime ? "" + paginationFilter_Filter_EndDateTime.toISOString() : "") + "&";
        if (paginationFilter_Filter_Status !== undefined && paginationFilter_Filter_Status !== null)
            url_ += "PaginationFilter.Filter.Status=" + encodeURIComponent("" + paginationFilter_Filter_Status) + "&";
        if (paginationFilter_CurrentPage === null)
            throw new Error("The parameter 'paginationFilter_CurrentPage' cannot be null.");
        else if (paginationFilter_CurrentPage !== undefined)
            url_ += "PaginationFilter.CurrentPage=" + encodeURIComponent("" + paginationFilter_CurrentPage) + "&";
        if (paginationFilter_PageSize === null)
            throw new Error("The parameter 'paginationFilter_PageSize' cannot be null.");
        else if (paginationFilter_PageSize !== undefined)
            url_ += "PaginationFilter.PageSize=" + encodeURIComponent("" + paginationFilter_PageSize) + "&";
        if (paginationFilter_SortBy === null)
            throw new Error("The parameter 'paginationFilter_SortBy' cannot be null.");
        else if (paginationFilter_SortBy !== undefined)
            url_ += "PaginationFilter.SortBy=" + encodeURIComponent("" + paginationFilter_SortBy) + "&";
        if (paginationFilter_SortOrder === null)
            throw new Error("The parameter 'paginationFilter_SortOrder' cannot be null.");
        else if (paginationFilter_SortOrder !== undefined)
            url_ += "PaginationFilter.SortOrder=" + encodeURIComponent("" + paginationFilter_SortOrder) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processGetPaginatedReservations(_response));
        });
    }

    protected processGetPaginatedReservations(response: Response): Promise<PaginationResponseOfReservationDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            });
        } else if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaginationResponseOfReservationDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PaginationResponseOfReservationDto>(null as any);
    }

    createReservation(command: CreateReservationCommand): Promise<number> {
        let url_ = this.baseUrl + "/api/Reservation";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processCreateReservation(_response));
        });
    }

    protected processCreateReservation(response: Response): Promise<number> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            });
        } else if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<number>(null as any);
    }

    updateReservation(command: UpdateReservationCommand): Promise<NoContent> {
        let url_ = this.baseUrl + "/api/Reservation";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processUpdateReservation(_response));
        });
    }

    protected processUpdateReservation(response: Response): Promise<NoContent> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            });
        } else if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = NoContent.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<NoContent>(null as any);
    }
}

export class VehicleClient extends ApiClientBase {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : window as any;
        this.baseUrl = this.getBaseUrl("", baseUrl);
    }

    getPaginatedVehicles(paginationFilter_Filter_VIN: string | null | undefined, paginationFilter_Filter_LicensePlate: string | null | undefined, paginationFilter_Filter_Year: number | null | undefined, paginationFilter_Filter_Mileage: number | null | undefined, paginationFilter_Filter_VehicleType: number | null | undefined, paginationFilter_Filter_Transmission: number | null | undefined, paginationFilter_Filter_FuelType: number | null | undefined, paginationFilter_Filter_Price: number | null | undefined, paginationFilter_CurrentPage: number | undefined, paginationFilter_PageSize: number | undefined, paginationFilter_SortBy: string | undefined, paginationFilter_SortOrder: string | undefined): Promise<PaginationResponseOfVehicleDto> {
        let url_ = this.baseUrl + "/api/Vehicle/paginated?";
        if (paginationFilter_Filter_VIN !== undefined && paginationFilter_Filter_VIN !== null)
            url_ += "PaginationFilter.Filter.VIN=" + encodeURIComponent("" + paginationFilter_Filter_VIN) + "&";
        if (paginationFilter_Filter_LicensePlate !== undefined && paginationFilter_Filter_LicensePlate !== null)
            url_ += "PaginationFilter.Filter.LicensePlate=" + encodeURIComponent("" + paginationFilter_Filter_LicensePlate) + "&";
        if (paginationFilter_Filter_Year !== undefined && paginationFilter_Filter_Year !== null)
            url_ += "PaginationFilter.Filter.Year=" + encodeURIComponent("" + paginationFilter_Filter_Year) + "&";
        if (paginationFilter_Filter_Mileage !== undefined && paginationFilter_Filter_Mileage !== null)
            url_ += "PaginationFilter.Filter.Mileage=" + encodeURIComponent("" + paginationFilter_Filter_Mileage) + "&";
        if (paginationFilter_Filter_VehicleType !== undefined && paginationFilter_Filter_VehicleType !== null)
            url_ += "PaginationFilter.Filter.VehicleType=" + encodeURIComponent("" + paginationFilter_Filter_VehicleType) + "&";
        if (paginationFilter_Filter_Transmission !== undefined && paginationFilter_Filter_Transmission !== null)
            url_ += "PaginationFilter.Filter.Transmission=" + encodeURIComponent("" + paginationFilter_Filter_Transmission) + "&";
        if (paginationFilter_Filter_FuelType !== undefined && paginationFilter_Filter_FuelType !== null)
            url_ += "PaginationFilter.Filter.FuelType=" + encodeURIComponent("" + paginationFilter_Filter_FuelType) + "&";
        if (paginationFilter_Filter_Price !== undefined && paginationFilter_Filter_Price !== null)
            url_ += "PaginationFilter.Filter.Price=" + encodeURIComponent("" + paginationFilter_Filter_Price) + "&";
        if (paginationFilter_CurrentPage === null)
            throw new Error("The parameter 'paginationFilter_CurrentPage' cannot be null.");
        else if (paginationFilter_CurrentPage !== undefined)
            url_ += "PaginationFilter.CurrentPage=" + encodeURIComponent("" + paginationFilter_CurrentPage) + "&";
        if (paginationFilter_PageSize === null)
            throw new Error("The parameter 'paginationFilter_PageSize' cannot be null.");
        else if (paginationFilter_PageSize !== undefined)
            url_ += "PaginationFilter.PageSize=" + encodeURIComponent("" + paginationFilter_PageSize) + "&";
        if (paginationFilter_SortBy === null)
            throw new Error("The parameter 'paginationFilter_SortBy' cannot be null.");
        else if (paginationFilter_SortBy !== undefined)
            url_ += "PaginationFilter.SortBy=" + encodeURIComponent("" + paginationFilter_SortBy) + "&";
        if (paginationFilter_SortOrder === null)
            throw new Error("The parameter 'paginationFilter_SortOrder' cannot be null.");
        else if (paginationFilter_SortOrder !== undefined)
            url_ += "PaginationFilter.SortOrder=" + encodeURIComponent("" + paginationFilter_SortOrder) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processGetPaginatedVehicles(_response));
        });
    }

    protected processGetPaginatedVehicles(response: Response): Promise<PaginationResponseOfVehicleDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            });
        } else if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaginationResponseOfVehicleDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PaginationResponseOfVehicleDto>(null as any);
    }

    getSimpleVehicles(): Promise<SimpleVehicleDto[]> {
        let url_ = this.baseUrl + "/api/Vehicle/simple";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processGetSimpleVehicles(_response));
        });
    }

    protected processGetSimpleVehicles(response: Response): Promise<SimpleVehicleDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            });
        } else if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SimpleVehicleDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SimpleVehicleDto[]>(null as any);
    }

    getSearchResultVehicles(pickupLocationId: number | null | undefined, pickupDate: Date | null | undefined, dropOffDate: Date | null | undefined): Promise<VehicleDto[]> {
        let url_ = this.baseUrl + "/api/Vehicle/searchResult?";
        if (pickupLocationId !== undefined && pickupLocationId !== null)
            url_ += "PickupLocationId=" + encodeURIComponent("" + pickupLocationId) + "&";
        if (pickupDate !== undefined && pickupDate !== null)
            url_ += "PickupDate=" + encodeURIComponent(pickupDate ? "" + pickupDate.toISOString() : "") + "&";
        if (dropOffDate !== undefined && dropOffDate !== null)
            url_ += "DropOffDate=" + encodeURIComponent(dropOffDate ? "" + dropOffDate.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processGetSearchResultVehicles(_response));
        });
    }

    protected processGetSearchResultVehicles(response: Response): Promise<VehicleDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            });
        } else if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(VehicleDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<VehicleDto[]>(null as any);
    }

    getVehicleById(id: number): Promise<VehicleDto> {
        let url_ = this.baseUrl + "/api/Vehicle/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processGetVehicleById(_response));
        });
    }

    protected processGetVehicleById(response: Response): Promise<VehicleDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            });
        } else if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = VehicleDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<VehicleDto>(null as any);
    }

    deleteVehicle(id: number): Promise<void> {
        let url_ = this.baseUrl + "/api/Vehicle/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processDeleteVehicle(_response));
        });
    }

    protected processDeleteVehicle(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            });
        } else if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    createVehicle(command: CreateVehicleCommand): Promise<void> {
        let url_ = this.baseUrl + "/api/Vehicle";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processCreateVehicle(_response));
        });
    }

    protected processCreateVehicle(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            });
        } else if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }
}

export class ProblemDetails implements IProblemDetails {
    type!: string | undefined;
    title!: string | undefined;
    status!: number | undefined;
    detail!: string | undefined;
    instance!: string | undefined;

    [key: string]: any;

    constructor(data?: IProblemDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.type = _data["type"];
            this.title = _data["title"];
            this.status = _data["status"];
            this.detail = _data["detail"];
            this.instance = _data["instance"];
        }
    }

    static fromJS(data: any): ProblemDetails {
        data = typeof data === 'object' ? data : {};
        let result = new ProblemDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["type"] = this.type;
        data["title"] = this.title;
        data["status"] = this.status;
        data["detail"] = this.detail;
        data["instance"] = this.instance;
        return data;
    }
}

export interface IProblemDetails {
    type: string | undefined;
    title: string | undefined;
    status: number | undefined;
    detail: string | undefined;
    instance: string | undefined;

    [key: string]: any;
}

export class LoginDto implements ILoginDto {
    email!: string;
    password!: string;

    constructor(data?: ILoginDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
            this.password = _data["password"];
        }
    }

    static fromJS(data: any): LoginDto {
        data = typeof data === 'object' ? data : {};
        let result = new LoginDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        data["password"] = this.password;
        return data;
    }
}

export interface ILoginDto {
    email: string;
    password: string;
}

export class UserDto implements IUserDto {
    id!: string | undefined;
    email!: string | undefined;
    name!: string | undefined;
    roles!: string[] | undefined;

    constructor(data?: IUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.email = _data["email"];
            this.name = _data["name"];
            if (Array.isArray(_data["roles"])) {
                this.roles = [] as any;
                for (let item of _data["roles"])
                    this.roles!.push(item);
            }
        }
    }

    static fromJS(data: any): UserDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["email"] = this.email;
        data["name"] = this.name;
        if (Array.isArray(this.roles)) {
            data["roles"] = [];
            for (let item of this.roles)
                data["roles"].push(item);
        }
        return data;
    }
}

export interface IUserDto {
    id: string | undefined;
    email: string | undefined;
    name: string | undefined;
    roles: string[] | undefined;
}

export class OptionsDto implements IOptionsDto {
    id!: number;
    name!: string | undefined;

    constructor(data?: IOptionsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): OptionsDto {
        data = typeof data === 'object' ? data : {};
        let result = new OptionsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data;
    }
}

export interface IOptionsDto {
    id: number;
    name: string | undefined;
}

export class ExtraServiceDto implements IExtraServiceDto {
    id!: number;
    name!: string;
    description!: string;
    price!: number;

    constructor(data?: IExtraServiceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.price = _data["price"];
        }
    }

    static fromJS(data: any): ExtraServiceDto {
        data = typeof data === 'object' ? data : {};
        let result = new ExtraServiceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["description"] = this.description;
        data["price"] = this.price;
        return data;
    }
}

export interface IExtraServiceDto {
    id: number;
    name: string;
    description: string;
    price: number;
}

export class UserInfoResponse implements IUserInfoResponse {
    firstName!: string | undefined;
    lastName!: string | undefined;
    phoneNumber!: string | undefined;
    email!: string | undefined;
    isEmailConfirmed!: boolean;

    constructor(data?: IUserInfoResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.phoneNumber = _data["phoneNumber"];
            this.email = _data["email"];
            this.isEmailConfirmed = _data["isEmailConfirmed"];
        }
    }

    static fromJS(data: any): UserInfoResponse {
        data = typeof data === 'object' ? data : {};
        let result = new UserInfoResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["phoneNumber"] = this.phoneNumber;
        data["email"] = this.email;
        data["isEmailConfirmed"] = this.isEmailConfirmed;
        return data;
    }
}

export interface IUserInfoResponse {
    firstName: string | undefined;
    lastName: string | undefined;
    phoneNumber: string | undefined;
    email: string | undefined;
    isEmailConfirmed: boolean;
}

export class UpdateUserInfoRequest extends UserInfoResponse implements IUpdateUserInfoRequest {
    newPassword!: string | undefined;
    oldPassword!: string | undefined;
    clientId!: string;

    constructor(data?: IUpdateUserInfoRequest) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.newPassword = _data["newPassword"];
            this.oldPassword = _data["oldPassword"];
            this.clientId = _data["clientId"];
        }
    }

    static fromJS(data: any): UpdateUserInfoRequest {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateUserInfoRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["newPassword"] = this.newPassword;
        data["oldPassword"] = this.oldPassword;
        data["clientId"] = this.clientId;
        super.toJSON(data);
        return data;
    }
}

export interface IUpdateUserInfoRequest extends IUserInfoResponse {
    newPassword: string | undefined;
    oldPassword: string | undefined;
    clientId: string;
}

export class LocationDto implements ILocationDto {
    id!: number;
    name!: string;
    address!: string;
    phoneNumber!: string;
    city!: string;
    image!: string;

    constructor(data?: ILocationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.address = _data["address"];
            this.phoneNumber = _data["phoneNumber"];
            this.city = _data["city"];
            this.image = _data["image"];
        }
    }

    static fromJS(data: any): LocationDto {
        data = typeof data === 'object' ? data : {};
        let result = new LocationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["address"] = this.address;
        data["phoneNumber"] = this.phoneNumber;
        data["city"] = this.city;
        data["image"] = this.image;
        return data;
    }
}

export interface ILocationDto {
    id: number;
    name: string;
    address: string;
    phoneNumber: string;
    city: string;
    image: string;
}

export class PaymentIntentResponse implements IPaymentIntentResponse {
    clientSecret!: string | undefined;
    paymentIntentId!: string | undefined;

    constructor(data?: IPaymentIntentResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.clientSecret = _data["clientSecret"];
            this.paymentIntentId = _data["paymentIntentId"];
        }
    }

    static fromJS(data: any): PaymentIntentResponse {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentIntentResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["clientSecret"] = this.clientSecret;
        data["paymentIntentId"] = this.paymentIntentId;
        return data;
    }
}

export interface IPaymentIntentResponse {
    clientSecret: string | undefined;
    paymentIntentId: string | undefined;
}

export class PaymentIntentRequest implements IPaymentIntentRequest {
    amount!: number;

    constructor(data?: IPaymentIntentRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.amount = _data["amount"];
        }
    }

    static fromJS(data: any): PaymentIntentRequest {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentIntentRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["amount"] = this.amount;
        return data;
    }
}

export interface IPaymentIntentRequest {
    amount: number;
}

export class NewPaymentResponse implements INewPaymentResponse {
    invoicePath!: string | undefined;

    constructor(data?: INewPaymentResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.invoicePath = _data["invoicePath"];
        }
    }

    static fromJS(data: any): NewPaymentResponse {
        data = typeof data === 'object' ? data : {};
        let result = new NewPaymentResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["invoicePath"] = this.invoicePath;
        return data;
    }
}

export interface INewPaymentResponse {
    invoicePath: string | undefined;
}

export class CreatePaymentCommand implements ICreatePaymentCommand {
    amount!: number;
    stripePaymentIntentId!: string;
    reservationId!: number | undefined;

    constructor(data?: ICreatePaymentCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.amount = _data["amount"];
            this.stripePaymentIntentId = _data["stripePaymentIntentId"];
            this.reservationId = _data["reservationId"];
        }
    }

    static fromJS(data: any): CreatePaymentCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreatePaymentCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["amount"] = this.amount;
        data["stripePaymentIntentId"] = this.stripePaymentIntentId;
        data["reservationId"] = this.reservationId;
        return data;
    }
}

export interface ICreatePaymentCommand {
    amount: number;
    stripePaymentIntentId: string;
    reservationId: number | undefined;
}

export class PaginationResponseOfPersonDto implements IPaginationResponseOfPersonDto {
    items!: PersonDto[];
    currentPage!: number;
    pageSize!: number;
    totalPages!: number;
    totalItems!: number;

    constructor(data?: IPaginationResponseOfPersonDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(PersonDto.fromJS(item));
            }
            this.currentPage = _data["currentPage"];
            this.pageSize = _data["pageSize"];
            this.totalPages = _data["totalPages"];
            this.totalItems = _data["totalItems"];
        }
    }

    static fromJS(data: any): PaginationResponseOfPersonDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaginationResponseOfPersonDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item ? item.toJSON() : <any>undefined);
        }
        data["currentPage"] = this.currentPage;
        data["pageSize"] = this.pageSize;
        data["totalPages"] = this.totalPages;
        data["totalItems"] = this.totalItems;
        return data;
    }
}

export interface IPaginationResponseOfPersonDto {
    items: PersonDto[];
    currentPage: number;
    pageSize: number;
    totalPages: number;
    totalItems: number;
}

export class PersonDto implements IPersonDto {
    id!: number;
    firstName!: string | undefined;
    lastName!: string | undefined;
    phoneNumber!: string | undefined;
    email!: string | undefined;
    isActive!: boolean;

    constructor(data?: IPersonDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.phoneNumber = _data["phoneNumber"];
            this.email = _data["email"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): PersonDto {
        data = typeof data === 'object' ? data : {};
        let result = new PersonDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["phoneNumber"] = this.phoneNumber;
        data["email"] = this.email;
        data["isActive"] = this.isActive;
        return data;
    }
}

export interface IPersonDto {
    id: number;
    firstName: string | undefined;
    lastName: string | undefined;
    phoneNumber: string | undefined;
    email: string | undefined;
    isActive: boolean;
}

export class CreateUserAndPersonCommand implements ICreateUserAndPersonCommand {
    firstName!: string | undefined;
    lastName!: string | undefined;
    phoneNumber!: string | undefined;
    email!: string | undefined;
    password!: string | undefined;
    role!: string | undefined;

    constructor(data?: ICreateUserAndPersonCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.phoneNumber = _data["phoneNumber"];
            this.email = _data["email"];
            this.password = _data["password"];
            this.role = _data["role"];
        }
    }

    static fromJS(data: any): CreateUserAndPersonCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateUserAndPersonCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["phoneNumber"] = this.phoneNumber;
        data["email"] = this.email;
        data["password"] = this.password;
        data["role"] = this.role;
        return data;
    }
}

export interface ICreateUserAndPersonCommand {
    firstName: string | undefined;
    lastName: string | undefined;
    phoneNumber: string | undefined;
    email: string | undefined;
    password: string | undefined;
    role: string | undefined;
}

export class NoContent implements INoContent {
    statusCode!: number;

    constructor(data?: INoContent) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.statusCode = _data["statusCode"];
        }
    }

    static fromJS(data: any): NoContent {
        data = typeof data === 'object' ? data : {};
        let result = new NoContent();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["statusCode"] = this.statusCode;
        return data;
    }
}

export interface INoContent {
    statusCode: number;
}

export class CreateRentalCommand implements ICreateRentalCommand {
    pickupDateTime!: Date;
    odometerStart!: number;
    notes!: string | undefined;
    reservationId!: number;

    constructor(data?: ICreateRentalCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.pickupDateTime = _data["pickupDateTime"] ? new Date(_data["pickupDateTime"].toString()) : <any>undefined;
            this.odometerStart = _data["odometerStart"];
            this.notes = _data["notes"];
            this.reservationId = _data["reservationId"];
        }
    }

    static fromJS(data: any): CreateRentalCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateRentalCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pickupDateTime"] = this.pickupDateTime ? this.pickupDateTime.toISOString() : <any>undefined;
        data["odometerStart"] = this.odometerStart;
        data["notes"] = this.notes;
        data["reservationId"] = this.reservationId;
        return data;
    }
}

export interface ICreateRentalCommand {
    pickupDateTime: Date;
    odometerStart: number;
    notes: string | undefined;
    reservationId: number;
}

export class PaginationResponseOfReservationDto implements IPaginationResponseOfReservationDto {
    items!: ReservationDto[];
    currentPage!: number;
    pageSize!: number;
    totalPages!: number;
    totalItems!: number;

    constructor(data?: IPaginationResponseOfReservationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ReservationDto.fromJS(item));
            }
            this.currentPage = _data["currentPage"];
            this.pageSize = _data["pageSize"];
            this.totalPages = _data["totalPages"];
            this.totalItems = _data["totalItems"];
        }
    }

    static fromJS(data: any): PaginationResponseOfReservationDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaginationResponseOfReservationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item ? item.toJSON() : <any>undefined);
        }
        data["currentPage"] = this.currentPage;
        data["pageSize"] = this.pageSize;
        data["totalPages"] = this.totalPages;
        data["totalItems"] = this.totalItems;
        return data;
    }
}

export interface IPaginationResponseOfReservationDto {
    items: ReservationDto[];
    currentPage: number;
    pageSize: number;
    totalPages: number;
    totalItems: number;
}

export class ReservationDto implements IReservationDto {
    id!: number;
    startDateTime!: Date;
    endDateTime!: Date;
    status!: ReservationStatus;
    confirmedAt!: Date | undefined;
    cancelledAt!: Date | undefined;
    totalPrice!: number;
    notes!: string | undefined;
    personName!: string;
    extraServices!: string[] | undefined;

    constructor(data?: IReservationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.startDateTime = _data["startDateTime"] ? new Date(_data["startDateTime"].toString()) : <any>undefined;
            this.endDateTime = _data["endDateTime"] ? new Date(_data["endDateTime"].toString()) : <any>undefined;
            this.status = _data["status"];
            this.confirmedAt = _data["confirmedAt"] ? new Date(_data["confirmedAt"].toString()) : <any>undefined;
            this.cancelledAt = _data["cancelledAt"] ? new Date(_data["cancelledAt"].toString()) : <any>undefined;
            this.totalPrice = _data["totalPrice"];
            this.notes = _data["notes"];
            this.personName = _data["personName"];
            if (Array.isArray(_data["extraServices"])) {
                this.extraServices = [] as any;
                for (let item of _data["extraServices"])
                    this.extraServices!.push(item);
            }
        }
    }

    static fromJS(data: any): ReservationDto {
        data = typeof data === 'object' ? data : {};
        let result = new ReservationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["startDateTime"] = this.startDateTime ? this.startDateTime.toISOString() : <any>undefined;
        data["endDateTime"] = this.endDateTime ? this.endDateTime.toISOString() : <any>undefined;
        data["status"] = this.status;
        data["confirmedAt"] = this.confirmedAt ? this.confirmedAt.toISOString() : <any>undefined;
        data["cancelledAt"] = this.cancelledAt ? this.cancelledAt.toISOString() : <any>undefined;
        data["totalPrice"] = this.totalPrice;
        data["notes"] = this.notes;
        data["personName"] = this.personName;
        if (Array.isArray(this.extraServices)) {
            data["extraServices"] = [];
            for (let item of this.extraServices)
                data["extraServices"].push(item);
        }
        return data;
    }
}

export interface IReservationDto {
    id: number;
    startDateTime: Date;
    endDateTime: Date;
    status: ReservationStatus;
    confirmedAt: Date | undefined;
    cancelledAt: Date | undefined;
    totalPrice: number;
    notes: string | undefined;
    personName: string;
    extraServices: string[] | undefined;
}

export enum ReservationStatus {
    Pending = 1,
    Confirmed = 2,
    Cancelled = 3,
    Completed = 4,
    NoShow = 5,
}

export class CreateReservationCommand implements ICreateReservationCommand {
    startDateTime!: Date;
    endDateTime!: Date;
    totalPrice!: number;
    notes!: string | undefined;
    vehicleId!: number;
    pickupLocationId!: number;
    reservationExtrasIds!: number[] | undefined;
    firstName!: string;
    lastName!: string | undefined;
    phoneNumber!: string | undefined;
    email!: string | undefined;

    constructor(data?: ICreateReservationCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.startDateTime = _data["startDateTime"] ? new Date(_data["startDateTime"].toString()) : <any>undefined;
            this.endDateTime = _data["endDateTime"] ? new Date(_data["endDateTime"].toString()) : <any>undefined;
            this.totalPrice = _data["totalPrice"];
            this.notes = _data["notes"];
            this.vehicleId = _data["vehicleId"];
            this.pickupLocationId = _data["pickupLocationId"];
            if (Array.isArray(_data["reservationExtrasIds"])) {
                this.reservationExtrasIds = [] as any;
                for (let item of _data["reservationExtrasIds"])
                    this.reservationExtrasIds!.push(item);
            }
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.phoneNumber = _data["phoneNumber"];
            this.email = _data["email"];
        }
    }

    static fromJS(data: any): CreateReservationCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateReservationCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["startDateTime"] = this.startDateTime ? this.startDateTime.toISOString() : <any>undefined;
        data["endDateTime"] = this.endDateTime ? this.endDateTime.toISOString() : <any>undefined;
        data["totalPrice"] = this.totalPrice;
        data["notes"] = this.notes;
        data["vehicleId"] = this.vehicleId;
        data["pickupLocationId"] = this.pickupLocationId;
        if (Array.isArray(this.reservationExtrasIds)) {
            data["reservationExtrasIds"] = [];
            for (let item of this.reservationExtrasIds)
                data["reservationExtrasIds"].push(item);
        }
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["phoneNumber"] = this.phoneNumber;
        data["email"] = this.email;
        return data;
    }
}

export interface ICreateReservationCommand {
    startDateTime: Date;
    endDateTime: Date;
    totalPrice: number;
    notes: string | undefined;
    vehicleId: number;
    pickupLocationId: number;
    reservationExtrasIds: number[] | undefined;
    firstName: string;
    lastName: string | undefined;
    phoneNumber: string | undefined;
    email: string | undefined;
}

export class UpdateReservationCommand implements IUpdateReservationCommand {
    id!: number;
    status!: ReservationStatus;
    confirmedAt!: Date | undefined;
    cancelledAt!: Date | undefined;

    constructor(data?: IUpdateReservationCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.status = _data["status"];
            this.confirmedAt = _data["confirmedAt"] ? new Date(_data["confirmedAt"].toString()) : <any>undefined;
            this.cancelledAt = _data["cancelledAt"] ? new Date(_data["cancelledAt"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): UpdateReservationCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateReservationCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["status"] = this.status;
        data["confirmedAt"] = this.confirmedAt ? this.confirmedAt.toISOString() : <any>undefined;
        data["cancelledAt"] = this.cancelledAt ? this.cancelledAt.toISOString() : <any>undefined;
        return data;
    }
}

export interface IUpdateReservationCommand {
    id: number;
    status: ReservationStatus;
    confirmedAt: Date | undefined;
    cancelledAt: Date | undefined;
}

export class PaginationResponseOfVehicleDto implements IPaginationResponseOfVehicleDto {
    items!: VehicleDto[];
    currentPage!: number;
    pageSize!: number;
    totalPages!: number;
    totalItems!: number;

    constructor(data?: IPaginationResponseOfVehicleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(VehicleDto.fromJS(item));
            }
            this.currentPage = _data["currentPage"];
            this.pageSize = _data["pageSize"];
            this.totalPages = _data["totalPages"];
            this.totalItems = _data["totalItems"];
        }
    }

    static fromJS(data: any): PaginationResponseOfVehicleDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaginationResponseOfVehicleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item ? item.toJSON() : <any>undefined);
        }
        data["currentPage"] = this.currentPage;
        data["pageSize"] = this.pageSize;
        data["totalPages"] = this.totalPages;
        data["totalItems"] = this.totalItems;
        return data;
    }
}

export interface IPaginationResponseOfVehicleDto {
    items: VehicleDto[];
    currentPage: number;
    pageSize: number;
    totalPages: number;
    totalItems: number;
}

export class VehicleDto implements IVehicleDto {
    id!: number;
    vin!: string;
    licensePlate!: string;
    year!: number;
    mileage!: number;
    vehicleType!: VehicleType;
    transmission!: Transmission;
    fuelType!: FuelType;
    power!: number;
    seats!: number;
    isAvailable!: boolean;
    price!: number;
    model!: ModelDto | undefined;
    location!: string;

    constructor(data?: IVehicleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.vin = _data["vin"];
            this.licensePlate = _data["licensePlate"];
            this.year = _data["year"];
            this.mileage = _data["mileage"];
            this.vehicleType = _data["vehicleType"];
            this.transmission = _data["transmission"];
            this.fuelType = _data["fuelType"];
            this.power = _data["power"];
            this.seats = _data["seats"];
            this.isAvailable = _data["isAvailable"];
            this.price = _data["price"];
            this.model = _data["model"] ? ModelDto.fromJS(_data["model"]) : <any>undefined;
            this.location = _data["location"];
        }
    }

    static fromJS(data: any): VehicleDto {
        data = typeof data === 'object' ? data : {};
        let result = new VehicleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["vin"] = this.vin;
        data["licensePlate"] = this.licensePlate;
        data["year"] = this.year;
        data["mileage"] = this.mileage;
        data["vehicleType"] = this.vehicleType;
        data["transmission"] = this.transmission;
        data["fuelType"] = this.fuelType;
        data["power"] = this.power;
        data["seats"] = this.seats;
        data["isAvailable"] = this.isAvailable;
        data["price"] = this.price;
        data["model"] = this.model ? this.model.toJSON() : <any>undefined;
        data["location"] = this.location;
        return data;
    }
}

export interface IVehicleDto {
    id: number;
    vin: string;
    licensePlate: string;
    year: number;
    mileage: number;
    vehicleType: VehicleType;
    transmission: Transmission;
    fuelType: FuelType;
    power: number;
    seats: number;
    isAvailable: boolean;
    price: number;
    model: ModelDto | undefined;
    location: string;
}

export enum VehicleType {
    Sedan = 1,
    SUV = 2,
    Coupe = 3,
    Convertible = 4,
    Hatchback = 5,
}

export enum Transmission {
    Automatic = 1,
    Manual = 2,
}

export enum FuelType {
    Diesel = 1,
    Petrol = 2,
    Electric = 3,
    Hybrid = 4,
    Gas = 5,
}

export class ModelDto implements IModelDto {
    id!: number;
    brandName!: string;
    modelName!: string;
    image!: string | undefined;

    constructor(data?: IModelDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.brandName = _data["brandName"];
            this.modelName = _data["modelName"];
            this.image = _data["image"];
        }
    }

    static fromJS(data: any): ModelDto {
        data = typeof data === 'object' ? data : {};
        let result = new ModelDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["brandName"] = this.brandName;
        data["modelName"] = this.modelName;
        data["image"] = this.image;
        return data;
    }
}

export interface IModelDto {
    id: number;
    brandName: string;
    modelName: string;
    image: string | undefined;
}

export class SimpleVehicleDto implements ISimpleVehicleDto {
    id!: number;
    name!: string;
    image!: string | undefined;
    price!: number;

    constructor(data?: ISimpleVehicleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.image = _data["image"];
            this.price = _data["price"];
        }
    }

    static fromJS(data: any): SimpleVehicleDto {
        data = typeof data === 'object' ? data : {};
        let result = new SimpleVehicleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["image"] = this.image;
        data["price"] = this.price;
        return data;
    }
}

export interface ISimpleVehicleDto {
    id: number;
    name: string;
    image: string | undefined;
    price: number;
}

export class CreateVehicleCommand implements ICreateVehicleCommand {
    vin!: string;
    licensePlate!: string;
    year!: number;
    mileage!: number;
    vehicleType!: VehicleType;
    transmission!: Transmission;
    fuelType!: FuelType;
    power!: number;
    seats!: number;
    price!: number;
    modelId!: number;
    locationId!: number;

    constructor(data?: ICreateVehicleCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.vin = _data["vin"];
            this.licensePlate = _data["licensePlate"];
            this.year = _data["year"];
            this.mileage = _data["mileage"];
            this.vehicleType = _data["vehicleType"];
            this.transmission = _data["transmission"];
            this.fuelType = _data["fuelType"];
            this.power = _data["power"];
            this.seats = _data["seats"];
            this.price = _data["price"];
            this.modelId = _data["modelId"];
            this.locationId = _data["locationId"];
        }
    }

    static fromJS(data: any): CreateVehicleCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateVehicleCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["vin"] = this.vin;
        data["licensePlate"] = this.licensePlate;
        data["year"] = this.year;
        data["mileage"] = this.mileage;
        data["vehicleType"] = this.vehicleType;
        data["transmission"] = this.transmission;
        data["fuelType"] = this.fuelType;
        data["power"] = this.power;
        data["seats"] = this.seats;
        data["price"] = this.price;
        data["modelId"] = this.modelId;
        data["locationId"] = this.locationId;
        return data;
    }
}

export interface ICreateVehicleCommand {
    vin: string;
    licensePlate: string;
    year: number;
    mileage: number;
    vehicleType: VehicleType;
    transmission: Transmission;
    fuelType: FuelType;
    power: number;
    seats: number;
    price: number;
    modelId: number;
    locationId: number;
}

export class ApiException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new ApiException(message, status, response, headers, null);
}

// Assuming you want to use a simple API client with no i18n or OIDC dependencies

export default ApiClientBase;